<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Professional Betting Bot Analyzer</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; color: #333; }
    .container { max-width: 1200px; margin: 0 auto; background: white; border-radius: 20px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.1); overflow: hidden; }
    .header { background: linear-gradient(135deg, #2c3e50, #34495e); color: white; padding: 40px 20px; text-align: center; }
    .header h1 { font-size: 2.5em; margin-bottom: 10px; }
    .header p { opacity: 0.9; font-size: 1.1em; }
    .content { padding: 40px 20px; }
    .form-group { margin-bottom: 30px; }
    label { display: block; margin-bottom: 10px; font-weight: 600; color: #2c3e50; font-size: 1.1em; }
    input[type="text"] { width: 100%; padding: 18px; border: 2px solid #e0e6ed; border-radius: 12px; font-size: 16px; transition: border-color 0.3s ease; }
    input[type="text"]:focus { outline: none; border-color: #667eea; }
    .btn { padding: 12px 16px; border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer;
      transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 1px; }
    .btn-primary { background: linear-gradient(135deg, #667eea, #764ba2); color: white; }
    .btn-success { background: linear-gradient(135deg, #2ecc71, #27ae60); color: white; }
    .btn:hover { transform: translateY(-3px); box-shadow: 0 15px 30px rgba(0,0,0,0.2); }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; box-shadow: none; }
    .toolbar { display:flex; gap:10px; flex-wrap:wrap; margin: 0 0 16px 0; }
    .progress { background: #f8f9fa; border-radius: 12px; overflow: hidden; margin: 25px 0; height: 15px; }
    .progress-bar { height: 100%; background: linear-gradient(90deg, #667eea, #764ba2); transition: width 0.5s ease; width: 0%; }
    .status { text-align: center; margin: 25px 0; padding: 20px; border-radius: 12px; font-weight: 500; font-size: 1.1em; }
    .status.testing { background: #e3f2fd; color: #1565c0; }
    .status.completed { background: #e8f5e8; color: #2e7d32; }
    .status.error { background: #ffebee; color: #c62828; }
    .results { margin-top: 24px; }
    .readiness-card { background: linear-gradient(135deg, #f8f9fa, #e9ecef); border-radius: 20px; padding: 32px; margin: 20px 0; text-align: center; border: 3px solid; }
    .readiness-excellent { border-color: #27ae60; background: linear-gradient(135deg, #d5f4e6, #c8e6c9); }
    .readiness-good { border-color: #3498db; background: linear-gradient(135deg, #e3f2fd, #bbdefb); }
    .readiness-moderate { border-color: #f39c12; background: linear-gradient(135deg, #fff3cd, #ffeaa7); }
    .readiness-insufficient { border-color: #e74c3c; background: linear-gradient(135deg, #ffebee, #ffcdd2); }
    .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin: 20px 0; }
    .stat-card { background: white; padding: 20px; border-radius: 15px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.1); }
    .section { background: #f8f9fa; border-radius: 15px; padding: 20px; margin: 20px 0; }
    .section h3 { margin-bottom: 12px; color: #2c3e50; font-size: 1.3em; display: flex; align-items: center; gap: 10px; }
    .list { display:grid; gap:10px; }
    .card { background: white; border-left: 5px solid #667eea; border-radius: 10px; padding: 12px 14px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
    .hidden { display: none; }
    pre.code { background:white;border-radius:12px;padding:16px;box-shadow:0 5px 15px rgba(0,0,0,0.05);overflow:auto; }
    @media (max-width: 768px) { .content { padding: 24px 14px; } }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>ü§ñ Professional Betting Bot Analyzer</h1>
      <p>SportMonks coverage for pre‚Äëmatch & in‚Äëplay prediction</p>
    </div>

    <div class="content">
      <form id="analysisForm">
        <div class="form-group">
          <label for="apiToken">SportMonks API Token</label>
          <input type="text" id="apiToken" placeholder="Enter your SportMonks API token..." required autocomplete="off" spellcheck="false"/>
        </div>
        <button type="submit" class="btn btn-primary" id="startBtn">üöÄ Start Complete Analysis</button>
      </form>

      <div id="progressSection" class="hidden">
        <div class="progress"><div class="progress-bar" id="progressBar"></div></div>
        <div class="status testing" id="statusText">Preparing comprehensive betting analysis...</div>
      </div>

      <div id="resultsSection" class="results hidden">
        <!-- Executive summary -->
        <div id="readinessCard" class="readiness-card">
          <div class="readiness-title" id="readinessTitle">Analyzing...</div>
          <div class="readiness-score" id="readinessScore">-</div>
          <div id="readinessDescription">Complete analysis in progress...</div>
        </div>
        <div class="summary-grid" id="summaryGrid"></div>

        <!-- Endpoint results -->
        <div class="section">
          <h3>üìã Endpoint Results</h3>
          <div class="list" id="resultList"></div>
        </div>

        <!-- Discovered IDs -->
        <div class="section">
          <h3>üÜî Discovered IDs</h3>
          <pre class="code" id="discoveredIds"></pre>
        </div>

        <!-- Today / Next 48h -->
        <div class="section">
          <h3>üìÖ Today & Next 48h</h3>
          <div class="toolbar">
            <button class="btn btn-primary" id="btnToday">Today</button>
            <button class="btn" id="btnNext48">Next 48h</button>
          </div>
          <div id="fixturesList" class="list"></div>
        </div>

        <!-- Fixture context -->
        <div class="section">
          <h3>üß† Fixture Context & Best Prices</h3>
          <div class="toolbar">
            <label>Fixture ID: <input id="fixtureIdInput" style="padding:8px;border:1px solid #ddd;border-radius:8px;width:140px"></label>
            <button class="btn btn-primary" id="btnLoadContext">Load</button>
          </div>
          <div id="fixtureContext" class="list"></div>
        </div>

        <!-- Predictions -->
        <div class="section">
          <h3>üéØ Bot Predictions</h3>
          <div class="toolbar">
            <button class="btn btn-primary" id="predictionsBtn">üîÆ Load Predictions</button>
            <label>Min Edge:
              <input id="minEdge" type="number" step="0.01" min="0" max="0.5" value="0.03" style="padding:8px;border:1px solid #ddd;border-radius:8px;width:100px;">
            </label>
            <label>Auto-refresh: <input id="autoRefresh" type="checkbox"></label>
          </div>
          <div id="predictionsList" class="list"></div>
        </div>

        <!-- In-Play -->
        <div class="section">
          <h3>‚ö° In‚ÄëPlay Pulse</h3>
          <div class="toolbar">
            <button class="btn btn-primary" id="pulseBtn">üì° Start Pulse</button>
            <button class="btn" id="pulseStopBtn">‚èπ Stop</button>
          </div>
          <div id="pulseList" class="list"></div>
        </div>

        <!-- Report -->
        <div class="section">
          <h3>üìÑ Complete Analysis Report</h3>
          <button class="btn btn-success" id="downloadBtn">üì• Download Complete Report</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    let testInterval, pulseTimer, autoRefreshTimer;
    let isTestRunning = false;

    const $ = (id) => document.getElementById(id);
    const code = (obj) => `<pre class="code">${typeof obj === 'string' ? obj : JSON.stringify(obj, null, 2)}</pre>`;

    $('analysisForm').addEventListener('submit', startAnalysis);
    $('downloadBtn').addEventListener('click', downloadReport);
    $('predictionsBtn').addEventListener('click', loadPredictions);
    $('pulseBtn').addEventListener('click', startPulse);
    $('pulseStopBtn').addEventListener('click', stopPulse);
    $('btnToday').addEventListener('click', loadToday);
    $('btnNext48').addEventListener('click', loadNext48);
    $('btnLoadContext').addEventListener('click', loadFixtureContext);
    $('autoRefresh').addEventListener('change', (e) => {
      if (e.target.checked) {
        if (autoRefreshTimer) clearInterval(autoRefreshTimer);
        autoRefreshTimer = setInterval(loadPredictions, 60000);
      } else if (autoRefreshTimer) {
        clearInterval(autoRefreshTimer); autoRefreshTimer = null;
      }
    });

    async function startAnalysis(e) {
      e.preventDefault();
      const apiToken = $('apiToken').value.trim();
      if (!apiToken || apiToken.length < 10) {
        alert('Please enter a valid SportMonks API token (at least 10 characters)');
        return;
      }
      try {
        const res = await fetch('/api/start-test', {
          method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ api_token: apiToken })
        });
        const data = await safeJson(res);
        if (!res.ok) throw new Error(data?.error || 'Failed to start analysis');

        isTestRunning = true;
        $('startBtn').disabled = true;
        $('startBtn').textContent = 'üîÑ Analysis Running...';
        $('progressSection').classList.remove('hidden');
        startProgressPolling();
      } catch (err) {
        alert('Error: ' + err.message);
        $('startBtn').disabled = false;
        $('startBtn').textContent = 'üöÄ Start Complete Analysis';
      }
    }

    function startProgressPolling() {
      testInterval = setInterval(async () => {
        try {
          const res = await fetch('/api/test-progress');
          const data = await safeJson(res);
          updateProgress(data?.progress || { current: 0, total: 0, status: 'idle' });

          if (data?.progress?.status === 'completed') {
            clearInterval(testInterval);
            isTestRunning = false;
            await loadResults();
            await loadPredictions();
          } else if (String(data?.progress?.status || '').includes('error')) {
            clearInterval(testInterval);
            isTestRunning = false;
            $('statusText').textContent = 'Error: ' + data.progress.status;
            $('statusText').className = 'status error';
            $('startBtn').disabled = false;
            $('startBtn').textContent = 'üöÄ Start Complete Analysis';
          }
        } catch (err) {
          console.error('Error fetch progress:', err);
        }
      }, 1000);
    }

    function updateProgress(progress) {
      const progressBar = $('progressBar');
      const statusText = $('statusText');
      const pct = progress.total > 0 ? (progress.current / progress.total) * 100 : 0;
      progressBar.style.width = pct + '%';
      if (progress.status === 'running') {
        statusText.textContent = `${progress.current_test || 'Working...'} (${progress.current}/${progress.total})`;
        statusText.className = 'status testing';
      } else if (progress.status === 'completed') {
        statusText.textContent = 'Complete professional analysis finished! üéâ';
        statusText.className = 'status completed';
      } else {
        statusText.textContent = 'Idle';
      }
    }

    async function loadResults() {
      try {
        const res = await fetch('/api/test-results');
        const data = await safeJson(res);
        if (!res.ok) throw new Error(data?.error || 'Failed to load results');

        displayResults(data);
        $('resultsSection').classList.remove('hidden');
        $('startBtn').disabled = false;
        $('startBtn').textContent = 'üöÄ Start Complete Analysis';
      } catch (err) {
        console.error('Error loading results:', err);
        alert('Error loading results: ' + err.message);
      }
    }

    function displayResults(payload) {
      const summary = payload?.summary || { total:0, successful:0, failed:0, success_rate:0, avg_response_time:0, total_data_items:0 };
      const results = Array.isArray(payload?.results) ? payload.results : [];
      const ids = payload?.discovered_ids || {};

      const sr = Number(summary.success_rate) || 0;
      let level = 'insufficient';
      if (sr >= 90) level = 'excellent';
      else if (sr >= 70) level = 'good';
      else if (sr >= 40) level = 'moderate';

      const readinessCard = $('readinessCard');
      readinessCard.className = `readiness-card readiness-${level}`;
      $('readinessTitle').textContent = level.toUpperCase();
      $('readinessScore').textContent = `${Math.round(sr)}/100`;
      $('readinessDescription').textContent =
        level === 'excellent' ? 'You have robust coverage for a professional-grade bot.' :
        level === 'good' ? 'Solid coverage. You can build an effective bot.' :
        level === 'moderate' ? 'Basic bot possible; consider adding more endpoints.' :
        'Coverage too thin‚Äîfix failing endpoints.';

      $('summaryGrid').innerHTML = `
        <div class="stat-card"><div class="stat-value">${summary.total}</div><div>Endpoints Tested</div></div>
        <div class="stat-card"><div class="stat-value" style="color:#27ae60">${summary.successful}</div><div>Successful</div></div>
        <div class="stat-card"><div class="stat-value" style="color:#e74c3c">${summary.failed}</div><div>Failed</div></div>
        <div class="stat-card"><div class="stat-value">${summary.success_rate}%</div><div>Success Rate</div></div>
        <div class="stat-card"><div class="stat-value">${summary.avg_response_time}s</div><div>Avg RT</div></div>
        <div class="stat-card"><div class="stat-value">${(summary.total_data_items||0).toLocaleString()}</div><div>Data Items</div></div>
      `;

      const list = $('resultList');
      list.innerHTML = results.length ? results.map(r => {
        const ok = r.success;
        const color = ok ? '#27ae60' : '#e74c3c';
        const msg = ok ? `${r.data_count} items` : (r.errors && r.errors[0]) || `HTTP ${r.status_code}`;
        const rt = (typeof r.response_time === 'number') ? r.response_time.toFixed(2) : r.response_time;
        return `<div class="card" style="border-left-color:${color}">
          <strong>${r.endpoint}</strong> ‚Äî <span style="color:${color}">${ok ? 'OK' : 'Failed'}</span>
          <br/>${msg} ‚Äî ${rt}s
        </div>`;
      }).join('') : '<p>No results yet.</p>';

      $('discoveredIds').textContent = JSON.stringify(ids, null, 2);
    }

    // ---- Today / Next48 ----
    async function loadToday() {
      const list = $('fixturesList'); list.innerHTML = 'Loading today...';
      const res = await fetch('/api/fixtures/today');
      const data = await safeJson(res);
      renderFixtures(list, (data && data.data) || []);
    }
    async function loadNext48() {
      const list = $('fixturesList'); list.innerHTML = 'Loading next 48h...';
      const res = await fetch('/api/fixtures/next48h');
      const data = await safeJson(res);
      renderFixtures(list, (data && data.data) || []);
    }
    function renderFixtures(container, arr) {
      if (!arr.length) { container.innerHTML = '<p>No fixtures found.</p>'; return; }
      container.innerHTML = arr.map(x => `
        <div class="card">
          <strong>${x.name || ('Fixture ' + x.id)}</strong>
          <div>${x.starting_at || ''}</div>
          ${x.league_id ? `<div>League: ${x.league_id}</div>` : ''}
          <div style="margin-top:6px;">
            <button class="btn btn-primary" onclick="loadContextById(${x.id})">Context</button>
          </div>
        </div>
      `).join('');
    }
    window.loadContextById = async (id) => { $('fixtureIdInput').value = id; await loadFixtureContext(); };

    // ---- Fixture context ----
    async function loadFixtureContext() {
      const id = Number($('fixtureIdInput').value.trim());
      if (!id) return alert('Enter a fixture ID');
      const box = $('fixtureContext'); box.innerHTML = 'Loading fixture context...';
      const res = await fetch(`/api/fixture/${id}/context`);
      const data = await safeJson(res);
      if (!data || data.error) { box.innerHTML = `<div class="card" style="border-left-color:#e74c3c">${data?.error || 'No data'}</div>`; return; }
      const f = data.fixture || {};
      const bp = data.best_prices_1x2 || {};
      const bpList = Object.keys(bp).length ? code(bp) : '‚Äî';
      box.innerHTML = `
        <div class="card"><strong>Fixture</strong>${code(f)}</div>
        <div class="card"><strong>Best 1X2 Prices</strong>${bpList}</div>
        <div class="card"><strong>Book% (1X2)</strong><div>${data.book_percentage_1x2 ?? '‚Äî'}%</div></div>
        <div class="card"><strong>Teams</strong>${code(data.teams || [])}</div>
        <div class="card"><strong>Recent</strong>${code(data.recent || {})}</div>
        <div class="card"><strong>H2H</strong>${code(data.h2h || [])}</div>
      `;
    }

    // ---- Predictions ----
    async function loadPredictions() {
      const btn = $('predictionsBtn');
      const list = $('predictionsList');
      const minEdge = parseFloat($('minEdge').value || '0.03');
      btn.disabled = true; const old = btn.textContent; btn.textContent = 'üîÑ Loading...';
      try {
        const res = await fetch('/api/predictions');
        const data = await safeJson(res);
        const preds = (data && data.predictions) || [];
        preds.forEach(p => {
          p.selections = (p.selections || []).filter(s => (s.edge || 0) >= minEdge);
          if (p.best && p.best.edge < minEdge) p.best = null;
        });
        list.innerHTML = preds
          .filter(p => p.best || (p.selections && p.selections.length))
          .map(renderPredictionCard).join('') || '<p>No selections passed the min edge filter.</p>';
      } catch (e) {
        list.innerHTML = `<div class="card" style="border-left-color:#e74c3c">Error: ${e.message}</div>`;
      } finally {
        btn.textContent = old; btn.disabled = false;
      }
    }

    function renderPredictionCard(p) {
      const best = p.best;
      const sels = Array.isArray(p.selections) ? p.selections : [];
      const bestHtml = best ? `
        <div class="card" style="border-left-color:#27ae60">
          <strong>${p.name || ('Fixture ' + p.fixture_id)}</strong>
          <div>${p.starting_at ? new Date(p.starting_at).toLocaleString() : ''}</div>
          <div><em>Best:</em> ${best.market} ‚Äî ${best.pick} @ <strong>${best.odds}</strong></div>
          <div>Edge: ${(best.edge * 100).toFixed(1)}% ¬∑ Kelly (¬º): ${(best.kelly_fraction * 100).toFixed(1)}% ${best.bookmaker_id ? `¬∑ BM: ${best.bookmaker_id}` : ''}</div>
          <small>${best.notes || ''}</small>
        </div>` : `<div class="card" style="border-left-color:#f39c12">No positive-edge selection found.</div>`;
      const listHtml = sels.map(s => `
        <div class="card" style="border-left-color:${s.edge > 0 ? '#27ae60' : '#e74c3c'}">
          ${s.market} ‚Äî <em>${s.pick}</em> @ <strong>${s.odds}</strong>
          &nbsp;¬∑ Edge ${(s.edge*100).toFixed(1)}% ¬∑ Kelly (¬º) ${(s.kelly_fraction*100).toFixed(1)}%
          ${s.bookmaker_id ? ` ¬∑ BM ${s.bookmaker_id}` : ''}<br/>
          <small>${s.notes || ''}</small>
        </div>
      `).join('');
      return bestHtml + listHtml;
    }

    // ---- In-play pulse ----
    async function startPulse() { if (pulseTimer) clearInterval(pulseTimer); await loadPulse(); pulseTimer = setInterval(loadPulse, 10000); }
    function stopPulse() { if (pulseTimer) clearInterval(pulseTimer); pulseTimer = null; }

    async function loadPulse() {
      const list = $('pulseList');
      list.innerHTML = 'Loading live snapshot...';
      try {
        const res = await fetch('/api/inplay');
        const data = await safeJson(res);
        const items = (data && data.data) || [];
        if (!items.length) { list.innerHTML = '<p>No live matches at the moment.</p>'; return; }
        list.innerHTML = items.map(it => `
          <div class="card">
            <strong>${it.name || ('Fixture ' + it.id)}</strong><br/>
            Time: ${(it.time && it.time.minute) ?? '-'}' ¬∑ Scores: ${it.scores ? JSON.stringify(it.scores) : '-'} ¬∑ State: ${it.state ? JSON.stringify(it.state) : '-'}
          </div>
        `).join('');
      } catch (e) {
        list.innerHTML = `<div class="card" style="border-left-color:#e74c3c">Error: ${e.message}</div>`;
      }
    }

    // ---- Report ----
    async function downloadReport() {
      const button = $('downloadBtn'); const old = button.textContent;
      button.disabled = true; button.textContent = 'üì• Generating Report...';
      try {
        const res = await fetch('/api/download-report');
        if (!res.ok) {
          const data = await safeJson(res);
          throw new Error(data?.error || 'Failed to download report');
        }
        const blob = await res.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `sportmonks_test_results_${new Date().toISOString().slice(0,10)}.json`; a.click();
        window.URL.revokeObjectURL(url);
        button.textContent = '‚úÖ Downloaded!';
        setTimeout(() => { button.textContent = old; button.disabled = false; }, 1500);
      } catch (err) {
        alert('Error downloading report: ' + err.message);
        button.textContent = old; button.disabled = false;
      }
    }

    async function safeJson(res) { try { return await res.json(); } catch { return null; } }
  </script>
</body>
</html>